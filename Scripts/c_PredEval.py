# -*- coding: utf-8 -*-
"""3_PredEval.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C-1y6LaFlaKZ8dV7LgX7uYJTmSxTUKiU
"""



"""## Imports"""

import io
import os
import gzip
import json
import scipy
import random
import warnings
import numpy as np
import numba as nb
import pandas as pd
import datetime as dt
import seaborn as sns
from tqdm import tqdm
import itertools
import scipy.stats as st
import scipy.sparse as sparse
from scipy.linalg import orth
import matplotlib.pyplot as plt
from numpy import linalg as lin
warnings.filterwarnings('ignore')
from scipy.sparse import coo_matrix
from scipy.sparse.linalg import svds
from datetime import datetime as dt_dt
from scipy.sparse.linalg import spsolve
from numpy.linalg import qr as QR_decomp
from collections import OrderedDict
from scipy.sparse import csr_matrix, find
from pandas.api.types import CategoricalDtype

"""### 1.Prediction"""

def topN_Index(a, n):
    parted = np.argpartition(a, -n)[-n:]
    return parted[np.argsort(-a[parted])]    

def TopNPred(RatingMat,holdout,V, user_column, N):  ##N == Top_N
    TestUsers = holdout[user_column]
    HOLDOUT_usersMat = RatingMat[TestUsers,:]         ##this doubles as the "previously seen items"
    PVVT =  HOLDOUT_usersMat.dot(V).dot(V.T) 
    users_column = HOLDOUT_usersMat.nonzero()[0]
    items_column = HOLDOUT_usersMat.nonzero()[1]
    args = np.array([users_column,items_column])
    np.put(PVVT, np.ravel_multi_index(args, PVVT.shape),-np.inf)   ##downsample previously seen items
    TopN_pred = np.apply_along_axis(topN_Index, 1,PVVT,n = N)
    return TopN_pred

def getALLTopNPred(RatingMat_List,HOLDOUT_list,V_list,user_column,N):
    All_TOPN_PRED = []
    for RatingMat,holdout,V in zip(RatingMat_List,HOLDOUT_list,V_list):  
        TopN_pred =  TopNPred(RatingMat,holdout,V, user_column, N)
        All_TOPN_PRED.append(TopN_pred)
    return All_TOPN_PRED

def TQDMgetALLTopNPred(RatingMat_List,HOLDOUT_list,V_list,user_column,N):
  All_TOPN_PRED = []
  for RatingMat,holdout,V in tqdm(zip(RatingMat_List,HOLDOUT_list,V_list)):  
    TopN_pred =  TopNPred(RatingMat,holdout,V, user_column, N)
    All_TOPN_PRED.append(TopN_pred)
  return All_TOPN_PRED

def TopNPred_ALLUSERS(RatingMat,V, N):  ##Prediction for all users ...||Not just Holdout
  PVVT =  RatingMat.dot(V).dot(V.T) 
  users_column = RatingMat.nonzero()[0]
  items_column = RatingMat.nonzero()[1]
  args = np.array([users_column,items_column])
  np.put(PVVT, np.ravel_multi_index(args, PVVT.shape),-np.inf)   ##downsample previously seen items
  TopN_pred = np.apply_along_axis(topN_Index, 1,PVVT,n = N)
  return TopN_pred

def getALLTopNPred_ALLUSERS(RatingMat_List,V_list,N):
  All_TOPN_PRED = []
  for RatingMat,V in zip(RatingMat_List,V_list):   
    TopN_pred =  TopNPred_ALLUSERS(RatingMat,V, N)
    All_TOPN_PRED.append(TopN_pred)
  return All_TOPN_PRED

def TQDMgetALLTopNPred_ALLUSERS(RatingMat_List,V_list,N):
  All_TOPN_PRED = []
  for RatingMat,V in tqdm(zip(RatingMat_List,V_list)):  
    TopN_pred =  TopNPred_ALLUSERS(RatingMat,V, N)
    All_TOPN_PRED.append(TopN_pred)
  return All_TOPN_PRED

"""### 2.Evaluation"""

def Hitrate_Eval(Holdout,TopN_pred,user_column,item_column):
    Eval_itemsVector  =  Holdout[[item_column]].to_numpy()
    HitRate_arr   =  (TopN_pred == Eval_itemsVector).sum(axis=1)  ##sum along row...
    HitCount = np.count_nonzero(HitRate_arr == 1)
    HitRate_ = HitRate_arr.mean()
    print("Number of hits: ", HitCount)
    print("Total Num of users: ",len(Holdout[user_column]))
    print("Recommendation HitRate: ",HitRate_)
    return HitRate_


def mean_confidence_interval(data, confidence=0.95):
    a = 1.0 * np.array(data)
    n = len(a)
    mean, se = np.mean(a), st.sem(a)
    h = se * scipy.stats.t.ppf((1 + confidence) / 2., n-1)
    lower_band =  mean-h
    upper_band =  mean+h
    return lower_band, mean,upper_band                ##LowerBand || Mean || UpperBand


def getAll_HitRate(HOLDOUT_list,All_TOPN_PRED,user_column,item_column):
    AllSteps_Hitrate = []
    for Holdout, TopN_pred in zip(HOLDOUT_list,All_TOPN_PRED):
        HitRate_ = Hitrate_Eval(Holdout,TopN_pred,user_column,item_column)
        AllSteps_Hitrate.append(HitRate_)

    LowerBand, Avg_HitRate, UpperBand  = mean_confidence_interval(AllSteps_Hitrate, confidence=0.95)
    print("Average HitRate for All Recommendations: ", Avg_HitRate)
    return AllSteps_Hitrate, LowerBand, Avg_HitRate, UpperBand



"""### 3.Random Rec"""

def TopN_RandomPred(RatingMat,holdout,user_column,N):   ##N == Top_N
  TestUsers = holdout[user_column]
  HOLDOUT_usersMat = RatingMat[TestUsers,:]    
  N_users,N_items = HOLDOUT_usersMat.shape   
  PVVT_RandScores = np.random.rand(N_users,N_items)   ##Assigns random scores to items
  users_column = HOLDOUT_usersMat.nonzero()[0]
  items_column = HOLDOUT_usersMat.nonzero()[1]
  args = np.array([users_column,items_column])
  np.put(PVVT_RandScores, np.ravel_multi_index(args, PVVT_RandScores.shape),-np.inf)   ##downsample previously seen items
  TopN_pred = np.apply_along_axis(topN_Index, 1,PVVT_RandScores,n = N)
  return TopN_pred

def get_ALLRandPred(RatingMat_List,HOLDOUT_list,user_column,N):
  All_RandPred = []
  for RatingMat,holdout in tqdm(zip(RatingMat_List,HOLDOUT_list)):  
    Rand_pred =  TopN_RandomPred(RatingMat,holdout,user_column, N)
    All_RandPred.append(Rand_pred)
  return All_RandPred


def getAll_RandomHitRate(HOLDOUT_list,All_RandPred,user_column,item_column):
  AllSteps_Hitrate = []
  for Holdout, Random_pred in zip(HOLDOUT_list,All_RandPred):  
    HitRate_ = Hitrate_Eval(Holdout,Random_pred,user_column,item_column)
    AllSteps_Hitrate.append(HitRate_)

  LowerBand, Avg_HitRate, UpperBand  = mean_confidence_interval(AllSteps_Hitrate, confidence=0.95)
  print("Average HitRate for All Recommendations: ", Avg_HitRate)
  return AllSteps_Hitrate, LowerBand, Avg_HitRate, UpperBand

def TopN_RandomPred_2(RatingMat,user_column,N):  
  N_users,N_items = RatingMat.shape   
  PVVT_RandScores = np.random.rand(N_users,N_items)   ##Assigns random scores to items
  users_column = RatingMat.nonzero()[0]
  items_column = RatingMat.nonzero()[1]
  args = np.array([users_column,items_column])
  np.put(PVVT_RandScores, np.ravel_multi_index(args, PVVT_RandScores.shape),-np.inf)   ##downsample previously seen items
  TopN_pred = np.apply_along_axis(topN_Index, 1,PVVT_RandScores,n = N)
  return TopN_pred

def get_ALLRandPred_2(RatingMat_List,user_column,N):
  All_RandPred = []
  for RatingMat in tqdm(RatingMat_List):  
    Rand_pred =  TopN_RandomPred_2(RatingMat,user_column, N)
    All_RandPred.append(Rand_pred)
  return All_RandPred


def getAll_RandomHitRate_2(HOLDOUT_list,All_RandPred,user_column,item_column):
  AllSteps_Hitrate = []
  for Holdout, Random_pred in zip(HOLDOUT_list,All_RandPred):  
    TestUsers = Holdout[user_column]
    HOLDOUT_RandPred = Random_pred[TestUsers,:]    
    HitRate_ = Hitrate_Eval(Holdout,HOLDOUT_RandPred,user_column,item_column)
    #HitRate_ = Sample_Hitrate(Holdout,HOLDOUT_RandPred,user_column,item_column)
    AllSteps_Hitrate.append(HitRate_)

  LowerBand, Avg_HitRate, UpperBand  = mean_confidence_interval(AllSteps_Hitrate, confidence=0.95)
  print("Average HitRate for All Recommendations: ", Avg_HitRate)
  return AllSteps_Hitrate, LowerBand, Avg_HitRate, UpperBand



"""### 4.Most POP Rec"""

def getMOSTPOP_Pred(DF,holdout,user_column,item_colum,N):  ##get the most popular item at a particular step
  top_counts= DF.groupby(item_colum)[user_column].count()    
  top_items = top_counts.sort_values(ascending=False) 
  MostPOP_Items = top_items[:N].index.values
  Nusers = holdout[user_column].nunique()  
  MostPOP_Pred = np.array([MostPOP_Items,]*Nusers)
  return MostPOP_Pred

def getAll_MOSTPOP_Pred(DF_list,HOLDOUT_list,user_column,item_colum,N):
  All_MostPOPRED_List = []
  for DF,holdout in zip(DF_list,HOLDOUT_list):
    MostPOP_Pred = getMOSTPOP_Pred(DF,holdout,user_column,item_colum,N)
    All_MostPOPRED_List.append(MostPOP_Pred) 
  return All_MostPOPRED_List

def getAll_MostPOPHitRate(HOLDOUT_list,All_MostPOPRED_List,user_column,item_column):
  AllSteps_Hitrate = []
  for Holdout, MostPOP_pred in zip(HOLDOUT_list,All_MostPOPRED_List): 
    HitRate_ = Hitrate_Eval(Holdout,MostPOP_pred,user_column,item_column)
    AllSteps_Hitrate.append(HitRate_)
  LowerBand, Avg_HitRate, UpperBand  = mean_confidence_interval(AllSteps_Hitrate, confidence=0.95)
  print("Average HitRate for All Recommendations: ", Avg_HitRate)
  return AllSteps_Hitrate, LowerBand, Avg_HitRate, UpperBand    

def getAll_MostPOPHitRate2(HOLDOUT_list,All_MostPOPRED_List,user_column,item_column):
  AllSteps_Hitrate = []
  for Holdout, MostPOP_pred in zip(HOLDOUT_list,All_MostPOPRED_List): 
    TestUsers = Holdout[user_column]
    Holdout_MostPOPred =  MostPOP_pred[TestUsers,:]  ##previous step prediction 
    HitRate_ = Sample_Hitrate(Holdout,Holdout_MostPOPred,user_column,item_column)
    AllSteps_Hitrate.append(HitRate_)
  LowerBand, Avg_HitRate, UpperBand  = mean_confidence_interval(AllSteps_Hitrate, confidence=0.95)
  return AllSteps_Hitrate, LowerBand, Avg_HitRate, UpperBand